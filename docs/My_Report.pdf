# Selection Sort (Student B) — Analysis Report

**Author:** Nuray Nuray  
**Course:** Design & Analysis of Algorithms  
**Date:** 2025-09-28  

---

## 1. Algorithm Overview

Selection Sort is one of the simplest comparison-based sorting algorithms.  
On the *k*-th iteration, the algorithm selects the smallest element from the unsorted suffix and places it into position *k*.  

### Optimizations Implemented:
- **Early Termination**: If during a pass no swaps occur, the algorithm terminates early, avoiding unnecessary iterations.  
- **Two-Way Selection**: In each pass, the algorithm simultaneously finds both the minimum and maximum elements. This optimization reduces the number of iterations by approximately half.  

### Properties:
- **In-place** (O(1) additional space).  
- **Not stable** (relative order of equal elements is not preserved).  
- **Swaps**: At most *n − 1*.  
- **Time**: Quadratic for most cases (Θ(n²)), but slightly reduced with early exit on nearly-sorted data.  

---

## 2. Complexity Analysis 

### Time Complexity
- **Best Case (Ω(n))**: If the array is already sorted, early termination stops after the first pass. Only O(n) comparisons are made, and almost no swaps.  
- **Average Case (Θ(n²))**: Regardless of distribution, the algorithm always performs ~n²/2 comparisons. Early termination rarely helps.  
- **Worst Case (O(n²))**: For reverse-sorted data, every pass performs both comparisons and swaps.  

### Operation Counts
- **Comparisons**: ~n(n − 1)/2 (≈ n²/2).  
- **Swaps**: At most n − 1.  
- **Reads/Writes**: Each swap involves 3 reads and 2 writes.  

### Space Complexity
- **O(1)** auxiliary memory (only a few temporary variables).  

### Comparison with Partner’s Algorithm (Insertion Sort)
- **Insertion Sort**: Best case Ω(n), average O(n²), worst O(n²).  
- **Selection Sort**: Comparisons are fixed (≈ n²/2) but fewer swaps.  
- **Insertion Sort** is better for nearly-sorted data due to shifting instead of swapping.  
- **Selection Sort** performs more consistently but lacks adaptivity.  

---

## 3. Code Review (Partner’s Algorithm A — Insertion Sort)

### Strengths:
- Straightforward and readable implementation.  
- Correct handling of edge cases (empty array, single element).  
- In-place algorithm with minimal memory footprint.  

### Bottlenecks:
- Uses linear search to find insertion position.  
- Too many shifts for reverse-sorted input (≈ n²/2 moves).  
- No early exit detection for already sorted input.  

### Suggested Optimizations:
1. **Binary Search Insertion**: Use binary search to locate the correct index in O(log n) time.  
   - Reduces comparisons significantly.  
   - Shifts remain O(n), so total time is still O(n²), but constants improve.  
2. **Early Exit**: If no shift was performed during a pass, terminate early.  
3. **Sentinel Optimization**: Place a sentinel at index 0 to avoid boundary checks.  

### Impact on Metrics:
- Fewer comparisons, especially on large inputs.  
- Improved performance on nearly-sorted data.  
- Complexity bounds remain the same, but practical runtime decreases.  

---

## 4. Empirical Results

Benchmarks were run with input sizes **n = 100, 1000, 10000, 100000** and distributions: random, sorted, reverse, nearly-sorted.  

### Sample Output (selection.csv excerpt):

### Observations:
- **Sorted input**: Very fast due to early termination, ~O(n).  
- **Reverse input**: Worst case, O(n²).  
- **Random input**: Matches theoretical ~n²/2 comparisons.  
- **Nearly-sorted**: Significant benefit from early termination.  

### Graphs:
Plots of **time vs n** show quadratic growth for random/reverse arrays, but almost linear growth for sorted input. This matches theoretical expectations.  

---

## 5. Conclusion (≈1 page)

Selection Sort is a simple but inefficient sorting algorithm for large inputs due to Θ(n²) time complexity.  
The **early termination** and **two-way optimization** slightly improve performance, especially for nearly-sorted or sorted data.  

In comparison, **Insertion Sort** is preferable for small or nearly-sorted arrays, while Selection Sort maintains predictable swap counts.  

### Final Recommendations:
- For academic demonstration, Selection Sort is valuable to illustrate algorithm analysis.  
- For practical usage, more efficient algorithms (Merge Sort, Quick Sort, Heap Sort) should be chosen.  
- The peer review of Insertion Sort revealed clear optimization opportunities (binary search insertion, early exit) that could substantially improve empirical performance.  

---